<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1D Physics Collision Engine</title>
    <style>
        :root {
            --color-background: #0f1419;
            --color-surface: #1a1f2e;
            --color-text: #e8eef7;
            --color-text-secondary: #a0aec0;
            --color-primary: #3b82f6;
            --color-primary-hover: #2563eb;
            --color-accent-blue: #60a5fa;
            --color-accent-red: #f87171;
            --color-success: #10b981;
            --color-border: #2d3748;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .subtitle {
            color: var(--color-text-secondary);
            margin-bottom: 24px;
            font-size: 14px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }

        /* Canvas Area */
        .canvas-wrapper {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 20px;
        }

        canvas {
            display: block;
            width: 100%;
            max-width: 100%;
            border-radius: 8px;
            background-color: #000;
        }

        /* Controls Section */
        .controls-section {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 20px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            background-color: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 16px;
        }

        .control-group h3 {
            font-size: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .square-indicator {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }

        .square-indicator.blue {
            background-color: var(--color-accent-blue);
        }

        .square-indicator.red {
            background-color: var(--color-accent-red);
        }

        .input-row {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .input-row:last-child {
            margin-bottom: 0;
        }

        label {
            font-size: 13px;
            color: var(--color-text-secondary);
            font-weight: 500;
        }

        input[type="number"] {
            padding: 10px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            background-color: rgba(255, 255, 255, 0.08);
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .action-buttons {
                grid-template-columns: 1fr 1fr;
            }
        }

        button {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }

        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .btn-success {
            background-color: var(--color-success);
            color: white;
        }

        .btn-success:hover {
            background-color: #059669;
        }

        button:active {
            transform: scale(0.98);
        }

        /* Info Panel */
        .info-panel {
            background-color: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .info-label {
            font-size: 12px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-text);
            font-family: 'Courier New', monospace;
        }

        .collision-status {
            grid-column: 1 / -1;
            padding: 12px;
            border-radius: 6px;
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--color-success);
            text-align: center;
            font-weight: 500;
            display: none;
        }

        .collision-status.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>1D Physics Collision Engine</h1>
        <p class="subtitle">Simulate elastic collisions between two solid squares on a 1D axis</p>

        <div class="main-content">
            <!-- Canvas -->
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <!-- Controls -->
            <div class="controls-section">
                <div class="controls-grid">
                    <!-- Square 1 (Left) -->
                    <div class="control-group">
                        <h3>
                            <span class="square-indicator blue"></span>
                            Square 1 (Left)
                        </h3>
                        <div class="input-row">
                            <label for="mass1">Mass (kg)</label>
                            <input type="number" id="mass1" value="5" min="0.1" step="0.1">
                        </div>
                        <div class="input-row">
                            <label for="velocity1">Velocity (m/s)</label>
                            <input type="number" id="velocity1" value="2" min="-20" max="20" step="0.5">
                        </div>
                    </div>

                    <!-- Square 2 (Right) -->
                    <div class="control-group">
                        <h3>
                            <span class="square-indicator red"></span>
                            Square 2 (Right)
                        </h3>
                        <div class="input-row">
                            <label for="mass2">Mass (kg)</label>
                            <input type="number" id="mass2" value="3" min="0.1" step="0.1">
                        </div>
                        <div class="input-row">
                            <label for="velocity2">Velocity (m/s)</label>
                            <input type="number" id="velocity2" value="-1" min="-20" max="20" step="0.5">
                        </div>
                    </div>

                    <!-- Friction Control -->
                    <div class="control-group" style="grid-column: 1 / -1;">
                        <h3>
                            Surface Friction
                        </h3>
                        <div class="input-row">
                            <label for="friction">Friction Coefficient (Î¼)</label>
                            <input type="range" id="friction" min="0" max="1" step="0.01" value="0.3" style="width: 100%; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                <span id="frictionValue" style="font-family: 'Courier New', monospace; font-weight: 600; color: var(--color-accent-blue);">0.30</span>
                                <span id="materialName" style="font-size: 12px; color: var(--color-text-secondary);">Wood on Wood</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn-primary" id="playBtn">&#9654; Play</button>
                    <button class="btn-secondary" id="pauseBtn">&#10074;&#10074; Pause</button>
                    <button class="btn-secondary" id="resetBtn">â†» Reset</button>
                    <button class="btn-secondary" id="clearBtn">Clear</button>
                </div>

                <!-- Info Panel -->
                <div class="info-panel">
                    <div class="info-item">
                        <span class="info-label">Square 1 Velocity</span>
                        <span class="info-value" id="v1Display">2.00</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Square 2 Velocity</span>
                        <span class="info-value" id="v2Display">-1.00</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Total Momentum</span>
                        <span class="info-value" id="momentumDisplay">7.00</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Total Kinetic Energy</span>
                        <span class="info-value" id="energyDisplay">6.50</span>
                    </div>
                    <div class="collision-status" id="collisionStatus">ðŸ”¥ COLLISION DETECTED!</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas setup
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width - 40;
            canvas.height = 200;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Physics constants
        const PADDING = 30;
        const SQUARE_SIZE = 30;
        const WALL_THICKNESS = 5;
        const GRAVITY = 9.81;
        let FRICTION_COEFFICIENT = 0.3;
        const RESTITUTION = 0.98;
        const WALL_RESTITUTION = 0.95;
        const STATIC_FRICTION_THRESHOLD = 0.01;

        // Simulation state
        let isRunning = false;
        let collisionDetected = false;
        let collisionTime = 0;

        // Square objects
        class Square {
            constructor(x, mass, velocity) {
                this.x = x;
                this.mass = mass;
                this.velocity = velocity;
                this.initialVelocity = velocity;
                this.initialX = x;
            }

            update(dt) {
                // Apply kinetic friction: F = -Î¼ * m * g â†’ a = -Î¼ * g
                const frictionAcceleration = FRICTION_COEFFICIENT * GRAVITY;
                
                // Reduce velocity based on friction direction
                if (Math.abs(this.velocity) > STATIC_FRICTION_THRESHOLD) {
                    this.velocity -= Math.sign(this.velocity) * frictionAcceleration * dt;
                } else {
                    // Static friction: stop if velocity is very small
                    this.velocity = 0;
                }
                
                this.x += this.velocity * dt;

                // Wall collision (left)
                if (this.x - SQUARE_SIZE / 2 < PADDING + WALL_THICKNESS) {
                    this.x = PADDING + WALL_THICKNESS + SQUARE_SIZE / 2;
                    this.velocity *= -WALL_RESTITUTION;
                }

                // Wall collision (right)
                const rightWall = canvas.width - PADDING - WALL_THICKNESS;
                if (this.x + SQUARE_SIZE / 2 > rightWall) {
                    this.x = rightWall - SQUARE_SIZE / 2;
                    this.velocity *= -WALL_RESTITUTION;
                }
            }

            draw(color) {
                ctx.fillStyle = color;
                ctx.fillRect(this.x - SQUARE_SIZE / 2, canvas.height / 2 - SQUARE_SIZE / 2, SQUARE_SIZE, SQUARE_SIZE);
            }

            getLeft() {
                return this.x - SQUARE_SIZE / 2;
            }

            getRight() {
                return this.x + SQUARE_SIZE / 2;
            }
        }

        let square1 = new Square(100, 5, 2);
        let square2 = new Square(canvas.width - 100, 3, -1);

        function initializeSquares() {
            const m1 = parseFloat(document.getElementById('mass1').value) || 5;
            const v1 = parseFloat(document.getElementById('velocity1').value) || 2;
            const m2 = parseFloat(document.getElementById('mass2').value) || 3;
            const v2 = parseFloat(document.getElementById('velocity2').value) || -1;

            square1 = new Square(PADDING + SQUARE_SIZE + 40, m1, v1);
            square2 = new Square(canvas.width - PADDING - SQUARE_SIZE - 40, m2, v2);

            updateInfoPanel();
        }

        function checkCollision() {
            const gap = square1.getRight() - square2.getLeft();
            return gap >= 0;
        }

        function handleCollision() {
            const m1 = square1.mass;
            const m2 = square2.mass;
            const v1 = square1.velocity;
            const v2 = square2.velocity;

            // Elastic collision formulas
            const v1_new = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2) * RESTITUTION;
            const v2_new = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2) * RESTITUTION;

            square1.velocity = v1_new;
            square2.velocity = v2_new;

            // Separate squares to avoid overlap
            const overlap = square1.getRight() - square2.getLeft();
            if (overlap > 0) {
                const separation = overlap / 2 + 0.5;
                square1.x -= separation;
                square2.x += separation;
            }

            collisionDetected = true;
            collisionTime = 0;
        }

        function updateInfoPanel() {
            document.getElementById('v1Display').textContent = square1.velocity.toFixed(2);
            document.getElementById('v2Display').textContent = square2.velocity.toFixed(2);

            const momentum = square1.mass * square1.velocity + square2.mass * square2.velocity;
            document.getElementById('momentumDisplay').textContent = momentum.toFixed(2);

            const energy = 0.5 * square1.mass * square1.velocity ** 2 + 0.5 * square2.mass * square2.velocity ** 2;
            document.getElementById('energyDisplay').textContent = energy.toFixed(2);

            // Show collision status
            const status = document.getElementById('collisionStatus');
            if (collisionDetected && collisionTime < 0.5) {
                status.classList.add('active');
                collisionTime += 0.016;
            } else {
                status.classList.remove('active');
            }
        }

        function drawEnvironment() {
            const workspaceTop = canvas.height / 2 - 50;
            const workspaceBottom = canvas.height / 2 + 50;

            // Background workspace
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fillRect(PADDING, workspaceTop, canvas.width - 2 * PADDING, 100);

            // Walls
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(PADDING, workspaceTop, WALL_THICKNESS, 100);
            ctx.fillRect(canvas.width - PADDING - WALL_THICKNESS, workspaceTop, WALL_THICKNESS, 100);

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(PADDING, workspaceTop, canvas.width - 2 * PADDING, 100);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawEnvironment();

            square1.draw('#60a5fa');
            square2.draw('#f87171');

            // Draw velocity vectors
            drawVelocityVector(square1, '#60a5fa');
            drawVelocityVector(square2, '#f87171');
        }

        function drawVelocityVector(square, color) {
            const startX = square.x;
            const startY = canvas.height / 2;
            const endX = startX + square.velocity * 10;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, startY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrow head
            const arrowSize = 8;
            const angle = square.velocity > 0 ? 0 : Math.PI;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(endX, startY);
            ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), startY - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), startY - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        function update(dt) {
            if (!isRunning) return;

            square1.update(dt);
            square2.update(dt);

            if (checkCollision()) {
                handleCollision();
            }

            updateInfoPanel();
        }

        function animate() {
            const dt = 0.016;
            update(dt);
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isRunning = true;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            initializeSquares();
            collisionDetected = false;
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            isRunning = false;
            square1.velocity = 0;
            square2.velocity = 0;
            square1.x = square1.initialX;
            square2.x = square2.initialX;
            collisionDetected = false;
            updateInfoPanel();
        });

        // Material friction reference
        const frictionMaterials = {
            0.02: 'Ice',
            0.15: 'Metal on Metal',
            0.25: 'Wood on Wood',
            0.40: 'Glass on Glass',
            0.70: 'Rubber on Asphalt'
        };

        // Get closest material name
        function getMaterialName(coefficient) {
            let closest = Object.keys(frictionMaterials)[0];
            let minDiff = Math.abs(coefficient - closest);
            
            for (let key of Object.keys(frictionMaterials)) {
                const diff = Math.abs(coefficient - key);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = key;
                }
            }
            return frictionMaterials[closest];
        }

        // Update squares when inputs change
        ['mass1', 'velocity1', 'mass2', 'velocity2'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (!isRunning) {
                    initializeSquares();
                }
            });
        });

        // Friction slider updates
        document.getElementById('friction').addEventListener('input', (e) => {
            FRICTION_COEFFICIENT = parseFloat(e.target.value);
            document.getElementById('frictionValue').textContent = FRICTION_COEFFICIENT.toFixed(2);
            document.getElementById('materialName').textContent = getMaterialName(FRICTION_COEFFICIENT);
        });

        // Initialize
        initializeSquares();
        animate();
    </script>
</body>
</html>
